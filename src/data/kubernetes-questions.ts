import { Question } from '@/types/game';

export const kubernetesQuestions: Question[] = [
  {
    id: 'k8s-001',
    levelId: 'kubernetes',
    difficulty: 'easy',
    question: 'What is the smallest deployable unit in Kubernetes?',
    options: ['Container object', 'Pod resource', 'Node instance', 'Deployment set'],
    correctAnswer: 1,
    explanation: 'A Pod is the smallest deployable unit in Kubernetes. It can contain one or more containers that share storage and network.',
    wrongFeedback: ['Containers run inside pods!', 'Correct! Pods are the atomic unit.', 'Nodes run pods, not the other way around.', 'Deployments manage pods.'],
    xpReward: 10,
    tags: ['pods', 'basics'],
  },
  {
    id: 'k8s-002',
    levelId: 'kubernetes',
    difficulty: 'easy',
    question: 'Which command lists all pods in all namespaces?',
    options: ['kubectl get pods', 'kubectl get pods --all-namespaces', 'kubectl list pods --global', 'kubectl pods --all-clusters'],
    correctAnswer: 1,
    explanation: 'kubectl get pods --all-namespaces (or -A) shows pods across all namespaces.',
    wrongFeedback: ['This only shows default namespace.', 'Correct! Or use -A for short.', 'list is not a kubectl command.', 'Invalid syntax.'],
    xpReward: 10,
    tags: ['kubectl', 'basics'],
  },
  {
    id: 'k8s-003',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'What does a ReplicaSet ensure in a cluster?',
    options: ['Containers restart on node failure', 'Specified pod replicas are running', 'Pods distribute across all zones', 'Services maintain load balance'],
    correctAnswer: 1,
    explanation: 'A ReplicaSet maintains a stable set of replica Pods running at any given time.',
    wrongFeedback: ['That\'s the kubelet\'s job.', 'Correct! ReplicaSets maintain desired replica count.', 'That\'s the scheduler\'s job.', 'Services handle load balancing.'],
    xpReward: 20,
    tags: ['replicaset', 'controllers'],
  },
  {
    id: 'k8s-004',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'Which resource exposes a Deployment externally?',
    options: ['ConfigMap resource', 'Secret object', 'Service endpoint', 'PersistentVolume claim'],
    correctAnswer: 2,
    explanation: 'Services expose Deployments to network traffic, either internally or externally via LoadBalancer or NodePort types.',
    wrongFeedback: ['ConfigMaps store configuration.', 'Secrets store sensitive data.', 'Correct! Services expose applications.', 'PVs handle storage.'],
    xpReward: 20,
    tags: ['services', 'networking'],
  },
  {
    id: 'k8s-005',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'What is the primary purpose of namespaces?',
    options: ['Isolate container process trees', 'Provide virtual cluster divisions', 'Encrypt network traffic flows', 'Manage container image layers'],
    correctAnswer: 1,
    explanation: 'Namespaces provide a mechanism for isolating groups of resources within a single cluster.',
    wrongFeedback: ['That\'s container isolation.', 'Correct! Namespaces create virtual clusters.', 'NetworkPolicies handle that.', 'That\'s registry\'s job.'],
    xpReward: 20,
    tags: ['namespaces', 'organization'],
  },
  {
    id: 'k8s-006',
    levelId: 'kubernetes',
    difficulty: 'hard',
    question: 'In Deployment spec, what does "maxSurge: 1" mean?',
    options: ['Only one pod may fail at once', 'One extra pod during updates', 'Updates run one node at a time', 'Maximum one total replica set'],
    correctAnswer: 1,
    explanation: 'maxSurge specifies the maximum number of pods that can be created over the desired number during an update.',
    wrongFeedback: ['That\'s maxUnavailable.', 'Correct! maxSurge allows temporary extra pods.', 'Not related to nodes.', 'That\'s replicas field.'],
    xpReward: 35,
    tags: ['deployments', 'rolling-update'],
  },
  {
    id: 'k8s-007',
    levelId: 'kubernetes',
    difficulty: 'hard',
    question: 'What happens when a Pod exceeds memory limit?',
    options: ['Gets CPU throttled', 'Gets OOMKilled', 'Gets evicted gracefully', 'Nothing, soft limit'],
    correctAnswer: 1,
    explanation: 'When a container exceeds its memory limit, it is terminated with OOMKilled status.',
    wrongFeedback: ['CPU is throttled, not memory.', 'Correct! OOMKilled terminates the container.', 'That\'s for resource pressure.', 'Limits are enforced.'],
    xpReward: 35,
    tags: ['resources', 'limits'],
  },
  {
    id: 'k8s-008',
    levelId: 'kubernetes',
    difficulty: 'hard',
    question: 'Which component assigns pods to nodes?',
    options: ['kubelet agent', 'kube-proxy daemon', 'kube-scheduler', 'etcd datastore'],
    correctAnswer: 2,
    explanation: 'The kube-scheduler watches for newly created Pods and assigns them to nodes.',
    wrongFeedback: ['Kubelet runs pods on nodes.', 'Kube-proxy handles networking.', 'Correct! Scheduler assigns pods.', 'etcd stores cluster state.'],
    xpReward: 35,
    tags: ['architecture', 'control-plane'],
  },
  {
    id: 'k8s-009',
    levelId: 'kubernetes',
    difficulty: 'evil',
    question: 'Pod is Pending: "0/3 nodes: Insufficient cpu". Best fix?',
    code: 'resources:\n  requests:\n    cpu: "4"\n    memory: "8Gi"',
    options: ['Add nodes or reduce request', 'Increase node CPU limits', 'Delete then recreate pod', 'Use limits instead request'],
    correctAnswer: 0,
    explanation: 'The pod requests more CPU than any node can provide. Either add nodes or reduce the CPU request.',
    wrongFeedback: ['Correct! Scale cluster or reduce requests.', 'Nodes don\'t have CPU limits.', 'Won\'t help if no resources available.', 'Limits don\'t affect scheduling.'],
    xpReward: 50,
    tags: ['troubleshooting', 'scheduling'],
  },
  {
    id: 'k8s-010',
    levelId: 'kubernetes',
    difficulty: 'evil',
    question: 'StatefulSet pods not created, PVC stuck Pending. Why?',
    options: ['StatefulSet name too long', 'No default StorageClass set', 'Pod security policy blocks', 'Service not created first'],
    correctAnswer: 1,
    explanation: 'StatefulSets need a StorageClass to dynamically provision PVs. Without a default, PVCs stay Pending.',
    wrongFeedback: ['Name length isn\'t the issue.', 'Correct! Set default StorageClass or specify one.', 'PSP wouldn\'t affect PVC.', 'Service isn\'t required for PVC.'],
    xpReward: 50,
    tags: ['statefulset', 'storage', 'troubleshooting'],
  },
  {
    id: 'k8s-011',
    levelId: 'kubernetes',
    difficulty: 'easy',
    question: 'What does kubectl apply -f manifest.yaml do?',
    options: ['Deletes resources defined', 'Creates or updates resources', 'Validates manifest only', 'Runs as a background job'],
    correctAnswer: 1,
    explanation: 'kubectl apply creates resources if they don\'t exist, or updates them if they do, based on the manifest.',
    wrongFeedback: ['That\'s kubectl delete.', 'Correct! Apply is declarative.', 'That\'s --dry-run.', 'Jobs need Job kind.'],
    xpReward: 10,
    tags: ['kubectl', 'basics'],
  },
  {
    id: 'k8s-012',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'What is an Ingress resource used for?',
    options: ['Internal pod communication', 'HTTP routing to services', 'Pod-to-pod encryption', 'Container orchestration'],
    correctAnswer: 1,
    explanation: 'Ingress manages external access to services, typically HTTP, providing load balancing, SSL, and name-based virtual hosting.',
    wrongFeedback: ['Services handle internal comms.', 'Correct! Ingress routes HTTP traffic.', 'That\'s service mesh territory.', 'That\'s K8s itself.'],
    xpReward: 20,
    tags: ['ingress', 'networking'],
  },
  {
    id: 'k8s-013',
    levelId: 'kubernetes',
    difficulty: 'hard',
    question: 'What is a PodDisruptionBudget\'s purpose?',
    options: ['Limit pod resource usage', 'Ensure minimum pods available', 'Prevent pod scheduling', 'Monitor pod health status'],
    correctAnswer: 1,
    explanation: 'PDBs limit voluntary disruptions to ensure a minimum number of pods stay available during maintenance.',
    wrongFeedback: ['ResourceQuotas do that.', 'Correct! PDBs protect availability.', 'Taints do that.', 'Probes monitor health.'],
    xpReward: 35,
    tags: ['pdb', 'availability'],
  },
  {
    id: 'k8s-014',
    levelId: 'kubernetes',
    difficulty: 'evil',
    question: 'Pods reach external but not each other. NetworkPolicy exists. Issue?',
    code: 'apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress',
    options: ['Missing egress policy', 'Empty selector blocks all', 'NetworkPolicy lacks ns', 'CNI plugin not working'],
    correctAnswer: 1,
    explanation: 'An empty podSelector {} selects all pods. With only Ingress type and no ingress rules, all incoming traffic is denied.',
    wrongFeedback: ['Egress isn\'t the issue here.', 'Correct! No ingress rules = deny all ingress.', 'Namespace is implicit.', 'Pods reach external, so CNI works.'],
    xpReward: 50,
    tags: ['networkpolicy', 'troubleshooting'],
  },
  {
    id: 'k8s-015',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'How to get logs from crashed pod\'s previous run?',
    options: ['kubectl logs pod --crashed', 'kubectl logs pod --previous', 'kubectl describe pod name', 'kubectl get events --pod'],
    correctAnswer: 1,
    explanation: 'The --previous flag shows logs from the previous instance of a container, useful for crash debugging.',
    wrongFeedback: ['Not a valid flag.', 'Correct! --previous shows old logs.', 'Describe shows events, not logs.', 'Events don\'t show container logs.'],
    xpReward: 20,
    tags: ['kubectl', 'debugging'],
  },
  {
    id: 'k8s-016',
    levelId: 'kubernetes',
    difficulty: 'easy',
    question: 'What is a DaemonSet used for?',
    options: ['Run pods on every node', 'Schedule pods randomly', 'Manage secrets storage', 'Handle DNS resolution'],
    correctAnswer: 0,
    explanation: 'A DaemonSet ensures that all (or some) nodes run a copy of a pod, useful for node agents.',
    wrongFeedback: ['Correct! DaemonSets run on every node.', 'That\'s the scheduler.', 'Secrets are different.', 'CoreDNS handles DNS.'],
    xpReward: 10,
    tags: ['daemonset', 'controllers'],
  },
  {
    id: 'k8s-017',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'What is the purpose of a HorizontalPodAutoscaler?',
    options: ['Scale nodes automatically', 'Scale pods based on metrics', 'Balance network traffic', 'Distribute storage evenly'],
    correctAnswer: 1,
    explanation: 'HPA automatically scales the number of pods based on observed CPU/memory utilization or custom metrics.',
    wrongFeedback: ['Cluster Autoscaler does that.', 'Correct! HPA scales pods.', 'Services do that.', 'StorageClass handles that.'],
    xpReward: 20,
    tags: ['hpa', 'autoscaling'],
  },
  {
    id: 'k8s-018',
    levelId: 'kubernetes',
    difficulty: 'hard',
    question: 'What is the difference between liveness and readiness probes?',
    options: ['No functional difference', 'Liveness restarts, readiness routes', 'Readiness restarts, liveness routes', 'Both restart the container'],
    correctAnswer: 1,
    explanation: 'Liveness probes restart unhealthy containers. Readiness probes control whether traffic is routed to the pod.',
    wrongFeedback: ['They serve different purposes.', 'Correct! Different purposes.', 'It\'s the opposite.', 'Only liveness restarts.'],
    xpReward: 35,
    tags: ['probes', 'health'],
  },
  {
    id: 'k8s-019',
    levelId: 'kubernetes',
    difficulty: 'evil',
    question: 'Pod CrashLoopBackOff but logs are empty. Where to look?',
    options: ['Check init containers', 'Check node memory', 'Check service endpoints', 'Check ingress rules'],
    correctAnswer: 0,
    explanation: 'If main container logs are empty but pod is crashing, check init containers - they run before main containers.',
    wrongFeedback: ['Correct! Init containers run first.', 'Memory would show OOMKilled.', 'Service doesn\'t cause crashes.', 'Ingress doesn\'t cause crashes.'],
    xpReward: 50,
    tags: ['troubleshooting', 'init-containers'],
  },
  {
    id: 'k8s-020',
    levelId: 'kubernetes',
    difficulty: 'medium',
    question: 'What is a ConfigMap used for?',
    options: ['Store sensitive passwords', 'Store non-sensitive config', 'Map network routes', 'Configure node settings'],
    correctAnswer: 1,
    explanation: 'ConfigMaps store non-confidential configuration data as key-value pairs that pods can consume.',
    wrongFeedback: ['Use Secrets for passwords.', 'Correct! ConfigMaps store config.', 'That\'s networking.', 'That\'s kubelet config.'],
    xpReward: 20,
    tags: ['configmap', 'configuration'],
  },
  {
    id: 'k8s-boss',
    levelId: 'kubernetes',
    difficulty: 'evil',
    question: 'üèÜ BOSS: Cascading failures, pods evicted, services unreachable. First command?',
    options: ['kubectl get pods -A', 'kubectl top nodes', 'kubectl get events --sort-by=time', 'kubectl describe nodes'],
    correctAnswer: 2,
    explanation: 'Getting sorted events shows you the timeline of what happened, crucial for understanding cascading failures.',
    wrongFeedback: ['Too basic for diagnosis.', 'Shows current state, not history.', 'Correct! Events show the failure timeline.', 'Useful but events are faster.'],
    xpReward: 100,
    tags: ['boss', 'troubleshooting', 'production'],
    isBoss: true,
  },
];
