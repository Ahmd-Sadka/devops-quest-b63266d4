import { Question } from '@/types/game';

export const terraformQuestions: Question[] = [
  {
    id: 'tf-001',
    levelId: 'terraform',
    difficulty: 'easy',
    question: 'What command initializes a Terraform working directory?',
    options: ['terraform start', 'terraform init', 'terraform begin', 'terraform setup'],
    correctAnswer: 1,
    explanation: 'terraform init initializes a working directory containing Terraform configuration files.',
    wrongFeedback: ['Not a Terraform command.', 'Correct! init downloads providers and modules.', 'Not valid.', 'Not a command.'],
    xpReward: 10,
    tags: ['basics', 'commands'],
  },
  {
    id: 'tf-002',
    levelId: 'terraform',
    difficulty: 'easy',
    question: 'What file extension do Terraform configuration files use?',
    options: ['.yaml', '.tf', '.hcl', '.json'],
    correctAnswer: 1,
    explanation: 'Terraform uses .tf files written in HCL (HashiCorp Configuration Language), though .tf.json is also valid.',
    wrongFeedback: ['YAML is for Kubernetes.', 'Correct! .tf is standard.', 'HCL is the language, not extension.', 'JSON is supported but not standard.'],
    xpReward: 10,
    tags: ['basics', 'syntax'],
  },
  {
    id: 'tf-003',
    levelId: 'terraform',
    difficulty: 'medium',
    question: 'What does terraform plan do?',
    options: ['Applies changes immediately', 'Creates an execution plan without making changes', 'Destroys all resources', 'Validates syntax only'],
    correctAnswer: 1,
    explanation: 'terraform plan creates an execution plan, showing what actions Terraform will take without making changes.',
    wrongFeedback: ['That\'s terraform apply.', 'Correct! Plan previews changes.', 'That\'s terraform destroy.', 'That\'s terraform validate.'],
    xpReward: 20,
    tags: ['commands', 'workflow'],
  },
  {
    id: 'tf-004',
    levelId: 'terraform',
    difficulty: 'medium',
    question: 'Where does Terraform store the state of managed infrastructure by default?',
    options: ['In AWS S3', 'In terraform.tfstate file locally', 'In HashiCorp Cloud', 'In .terraform directory'],
    correctAnswer: 1,
    explanation: 'By default, Terraform stores state in a local file named terraform.tfstate.',
    wrongFeedback: ['That\'s a remote backend option.', 'Correct! Local state file by default.', 'Cloud is optional.', '.terraform stores providers.'],
    xpReward: 20,
    tags: ['state', 'basics'],
  },
  {
    id: 'tf-005',
    levelId: 'terraform',
    difficulty: 'medium',
    question: 'What is the purpose of a Terraform provider?',
    options: ['To store variables', 'To interact with APIs of cloud platforms', 'To encrypt state files', 'To manage team permissions'],
    correctAnswer: 1,
    explanation: 'Providers are plugins that Terraform uses to interact with cloud providers, SaaS providers, and other APIs.',
    wrongFeedback: ['Variables are separate.', 'Correct! Providers enable API interactions.', 'That\'s backend encryption.', 'That\'s Terraform Cloud.'],
    xpReward: 20,
    tags: ['providers', 'basics'],
  },
  {
    id: 'tf-006',
    levelId: 'terraform',
    difficulty: 'hard',
    question: 'What does "terraform state mv" do?',
    options: ['Moves resources between providers', 'Renames resources in state', 'Migrates state to remote backend', 'Moves files between directories'],
    correctAnswer: 1,
    explanation: 'terraform state mv moves or renames resources in the state file without destroying them.',
    wrongFeedback: ['Can\'t move between providers.', 'Correct! Renames without destroy/recreate.', 'That\'s terraform init -migrate-state.', 'Not a file operation.'],
    xpReward: 35,
    tags: ['state', 'advanced'],
  },
  {
    id: 'tf-007',
    levelId: 'terraform',
    difficulty: 'hard',
    question: 'What is the purpose of the "count" meta-argument?',
    options: ['Count resources in state', 'Create multiple instances of a resource', 'Limit API calls', 'Track resource versions'],
    correctAnswer: 1,
    explanation: 'The count meta-argument creates multiple instances of a resource based on a numeric value.',
    wrongFeedback: ['State list does that.', 'Correct! count creates multiple copies.', 'Rate limiting is provider-side.', 'Versioning is separate.'],
    xpReward: 35,
    tags: ['meta-arguments', 'loops'],
  },
  {
    id: 'tf-008',
    levelId: 'terraform',
    difficulty: 'hard',
    question: 'What is the difference between "count" and "for_each"?',
    options: ['No difference, they\'re aliases', 'count uses numbers, for_each uses maps/sets', 'for_each is deprecated', 'count is for modules only'],
    correctAnswer: 1,
    explanation: 'count uses a number to create indexed instances, while for_each uses a map or set for named instances.',
    wrongFeedback: ['They\'re different.', 'Correct! Different use cases.', 'for_each is recommended.', 'Both work with resources.'],
    xpReward: 35,
    tags: ['meta-arguments', 'loops'],
  },
  {
    id: 'tf-009',
    levelId: 'terraform',
    difficulty: 'evil',
    question: 'Your terraform apply fails with "Error: Cycle" involving two resources. What\'s the solution?',
    code: 'resource "aws_security_group" "a" {\n  ingress {\n    security_groups = [aws_security_group.b.id]\n  }\n}\nresource "aws_security_group" "b" {\n  ingress {\n    security_groups = [aws_security_group.a.id]\n  }\n}',
    options: ['Use depends_on to break cycle', 'Use separate security group rules resources', 'Delete and recreate both', 'Increase parallelism'],
    correctAnswer: 1,
    explanation: 'Circular dependencies in inline rules can be broken by using separate aws_security_group_rule resources.',
    wrongFeedback: ['depends_on won\'t help cycles.', 'Correct! Separate rules break the cycle.', 'Won\'t fix the config issue.', 'Parallelism doesn\'t affect cycles.'],
    xpReward: 50,
    tags: ['troubleshooting', 'dependencies'],
  },
  {
    id: 'tf-010',
    levelId: 'terraform',
    difficulty: 'evil',
    question: 'State shows resource exists but cloud console doesn\'t. terraform plan says "No changes". What happened?',
    options: ['Resource was manually deleted', 'State is corrupted', 'Provider cache is stale', 'terraform refresh needed'],
    correctAnswer: 3,
    explanation: 'Terraform needs refresh to sync state with actual infrastructure. Run terraform refresh or plan -refresh-only.',
    wrongFeedback: ['Yes, but plan should detect it after refresh.', 'Unlikely.', 'Not how providers work.', 'Correct! Refresh syncs state with reality.'],
    xpReward: 50,
    tags: ['state', 'troubleshooting'],
  },
  {
    id: 'tf-011',
    levelId: 'terraform',
    difficulty: 'easy',
    question: 'How do you destroy all Terraform-managed infrastructure?',
    options: ['terraform delete', 'terraform destroy', 'terraform remove', 'terraform clean'],
    correctAnswer: 1,
    explanation: 'terraform destroy removes all resources defined in your Terraform configuration.',
    wrongFeedback: ['Not a command.', 'Correct! destroy removes all.', 'Not valid.', 'Not a command.'],
    xpReward: 10,
    tags: ['commands', 'basics'],
  },
  {
    id: 'tf-012',
    levelId: 'terraform',
    difficulty: 'medium',
    question: 'What is a Terraform module?',
    options: ['A single .tf file', 'A container for multiple resources that are used together', 'A cloud provider plugin', 'A state file backup'],
    correctAnswer: 1,
    explanation: 'A module is a container for multiple resources that are used together, promoting reusability.',
    wrongFeedback: ['Files aren\'t modules alone.', 'Correct! Modules group resources.', 'That\'s a provider.', 'That\'s state management.'],
    xpReward: 20,
    tags: ['modules', 'organization'],
  },
  {
    id: 'tf-013',
    levelId: 'terraform',
    difficulty: 'hard',
    question: 'What does the "lifecycle" block with "prevent_destroy = true" do?',
    options: ['Prevents accidental deletion of resources', 'Makes resources immutable', 'Disables terraform destroy command', 'Creates backup before changes'],
    correctAnswer: 0,
    explanation: 'prevent_destroy causes Terraform to reject any plan that would destroy the resource.',
    wrongFeedback: ['Correct! Protects critical resources.', 'Resources can still be updated.', 'destroy works on other resources.', 'No backup functionality.'],
    xpReward: 35,
    tags: ['lifecycle', 'safety'],
  },
  {
    id: 'tf-014',
    levelId: 'terraform',
    difficulty: 'evil',
    question: 'Team members are overwriting each other\'s changes. State is inconsistent. What\'s the enterprise solution?',
    options: ['Use .gitignore for state files', 'Implement remote backend with state locking', 'Run terraform sequentially', 'Disable team access'],
    correctAnswer: 1,
    explanation: 'Remote backends with state locking (S3+DynamoDB, Terraform Cloud) prevent concurrent modifications.',
    wrongFeedback: ['Doesn\'t solve concurrency.', 'Correct! Locking prevents conflicts.', 'Not scalable.', 'Not practical.'],
    xpReward: 50,
    tags: ['state', 'enterprise', 'collaboration'],
  },
  {
    id: 'tf-boss',
    levelId: 'terraform',
    difficulty: 'evil',
    question: 'üèÜ BOSS BATTLE: Your terraform state is corrupted and you have no backup. Production is running. How do you recover?',
    options: ['terraform destroy and start over', 'Use terraform import to rebuild state', 'Restore from terraform.tfstate.backup', 'Contact HashiCorp support'],
    correctAnswer: 1,
    explanation: 'terraform import can rebuild state by importing existing resources. Never destroy production without state!',
    wrongFeedback: ['Never destroy production blindly!', 'Correct! Import rebuilds state from existing resources.', 'No backup was stated.', 'Support can\'t recover your state.'],
    xpReward: 100,
    tags: ['boss', 'disaster-recovery', 'state'],
    isBoss: true,
  },
];
